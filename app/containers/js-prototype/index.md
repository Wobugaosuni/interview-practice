## 为什么有原型链？

- 提供一个向上查找属性和方法的能力

- 通过原型对象共享方法，而不用为每个实例创建对应的实例方法

- 代码复用和实现继承

## 原型的弊端

- 原型对象的基本类型的属性的共享对于实例对象而言非常的高效便捷
但是引用类型的属性存放的是一个指针，一旦修改一个实例对象的属性，所以的实例都会改动

## 继承

#### 原型链继承

优点：实现了方法的共享
弊端：在原型中使用引用类型的属性，在所有的实例对象中的该属性都引用了同一个物理空间，一旦空间的值发生了变化，那么所有实例对象的该属性值就发生了变化

#### 借用构造函数继承（经典继承）

优点：解决了引用值类型共享物理空间的问题
缺点：没法实现方法的共享

#### 组合继承（伪经典继承）

优点：解决了引用值类型共享的问题，又实现了方法的共享
缺点：会调用两次父类的构造函数

#### 寄生组合继承

优点：解决了子类原型对象中存在父类实例对象的属性的问题

## ES5类继承 和 ES6类继承 的区别

本质：代码复用

1. ES5 的继承使用借助构造函数实现，先创造子类的实例对象this，然后再将父类的方法添加到this上面
ES6 的继承，先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this

2. 在ES5中则是子类的`__proto__`指向父类的`prototype`
在ES6中子类的`__proto__`指向父类
```js
class Super {}
class Sub extends Super {}
const sub = new Sub();

Sub.__proto__ === Super;
```

3. ES5的原型对象是可枚举的
ES6不可枚举

## new操作做了什么事情

```js
var obj  = {};
obj.__proto__ = F.prototype;
F.call(obj);
```

第一行，我们创建了一个空对象obj;
第二行，我们将这个空对象的__proto__成员指向了F函数对象prototype成员对象;
第三行，我们将F函数对象的this指针替换成obj，然后再调用F函数.

我们可以这么理解: 以 new 操作符调用构造函数的时候，函数内部实际上发生以下变化：
1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this.

## 文档参考

- [js类和继承](https://github.com/ziyi2/js/blob/master/JS%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF.md)

- [JS原型链与继承别再被问倒了](https://juejin.im/post/58f94c9bb123db411953691b#heading-4)