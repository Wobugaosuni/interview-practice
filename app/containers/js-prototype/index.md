## 为什么有原型链？

- 提供一个向上查找属性和方法的能力

- 通过原型对象共享方法，而不用为每个实例创建对应的实例方法

- 代码复用和实现继承

## 原型的弊端

- 原型对象的基本类型的属性的共享对于实例对象而言非常的高效便捷
但是引用类型的属性存放的是一个指针，一旦修改一个实例对象的属性，所以的实例都会改动

## 继承

#### 原型链继承

优点：实现了方法的共享
弊端：在原型中使用引用类型的属性，在所有的实例对象中的该属性都引用了同一个物理空间，一旦空间的值发生了变化，那么所有实例对象的该属性值就发生了变化

#### 借用构造函数继承（经典继承）

优点：解决了引用值类型共享物理空间的问题
缺点：没法实现方法的共享

#### 组合继承（伪经典继承）

优点：解决了引用值类型共享的问题，又实现了方法的共享
缺点：会调用两次父类的构造函数

#### 寄生组合继承

优点：解决了子类原型对象中存在父类实例对象的属性的问题

## ES5类继承 和 ES6类继承 的区别

本质：代码复用

1. ES5 的继承使用借助构造函数实现，先创造子类的实例对象this，然后再将父类的方法添加到this上面
ES6 的继承，先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this

2. 在ES5中则是子类的`__proto__`指向父类的`prototype`
在ES6中子类的`__proto__`指向父类
  ```js
  class Super {}
  class Sub extends Super {}
  const sub = new Sub();
  Sub.__proto__ === Super;
  ```

3. ES5的原型对象是可枚举的
ES6不可枚举

## 文档参考

- [js类和继承](https://github.com/ziyi2/js/blob/master/JS%E7%B1%BB%E5%92%8C%E7%BB%A7%E6%89%BF.md)

- [JS原型链与继承别再被问倒了](https://juejin.im/post/58f94c9bb123db411953691b#heading-4)